{"/":{"title":"Shubham's Digital Gardenü™¥","content":"Hi, there üëã. My name is Shubham. I am skilled at solving real world problems with available resources. I am fortunate enough to work alongside so many extraordinary people and learn from them. I set aside a few minutes every day to share what I'm learning here in my digital garden. You can find more about me [[about_me|here]].\n\nIn this garden üè°, I publish my learning journey, and projects as [obsidian](https://obsidian.md/) notes that I will continue to maintain. There is no perfect end state, and it will always be a work in progress!\n\n## Recent Notes\n- [[random/java_11_collections|Java 11 Fundamentals: Collections]]\n- [[notes/oauth2|The OAuth 2.0 Authorization Framework]]\n- [[devops/gh_contribution|Github: Contribution Workflow]]","lastmodified":"2022-05-23T10:02:02.311103664Z","tags":null},"/books/sys_design_alex_xu":{"title":"System Design Interview by Alex Xu","content":"Available hereüëâ[System Design Interview ‚Äì An insider's guide eBook : Xu, Alex: Amazon.in: Kindle Store](https://www.amazon.in/System-Design-Interview-Insiders-Guide-ebook/dp/B08B3FWYBX)","lastmodified":"2022-05-23T10:02:02.311103664Z","tags":null},"/devops/gh_contribution":{"title":"Github: Contribution Workflow","content":"This note covers the workflow I use to contribute to open-source projects. I am using `github.com` for simplicity, but basic concepts are the same for all git-based VCS.\n\n## Finding Interesting Projects\nWhen starting your open source contribution journey, the first step is to find a project that interests you. Many sites index good issues for beginners. I am listing down a few sites which I felt comfortable using when getting started.\n- [Good First Issues](https://goodfirstissues.com/index.html)\n- [Up For Grabs (up-for-grabs.net)](https://up-for-grabs.net/#/)\n\n## Forking Repository\nOnce, you have figured out which project you want to contribute to, you can create a fork. A fork in github is an exact copy of some existing repository but under your username or org. You have full access to the forked repository, consider it your copy of code. You are going to add stuff here.\n![[Excalidraw/github/fork.excalidraw.png]]\n\n## Developing in Forked Repository\nBefore you can start contributing to any project, you need to first clone the forked repository in your development machine. Cloning will bring a copy of your forked repository to your local system. Once you have cloned the forked repository, you can start doing changes.  In the figure below, we start by creating `file1` in step 3 and committing them to the local branch `feature-branch`. After committing targeted changes in the local branch, you can push this local branch to a remote forked repository. After reviewing code changes, you can either merge these changes to the `main` branch or create a pull request against the `upstream` source project. The following figure shows the workflow used to do changes in a forked repo.\n![[Excalidraw/github/develop-in-fork.excalidraw.png]]\n\n### Staging changes\nAny file changes(including creation \u0026 deletion) stay in the working area by default. Git also provides us with a preparation area called staging. Whatever is present in staging gets saved permanently to `.git` when we commit. The following figure shows how the file changes move when using git commands.\n![[Excalidraw/github/staging-process.excalidraw.png]]\n\n## Pull Requests\nPull requests are not part of git, but rather part of git-based websites. Pull requests provide easy to use interface to review changes done by contributors and approve, request changes or merge them in your repo. A pull request has 2 parts to it, `base(target)` refers to the place where you want to contribute, and `compare(source)` refers to the place from where the changes should be picked for contribution. Both `base` and `compare` can refer to different repo and branch. The following figure shows how pull requests help maintainers merge changes to their repositories.\n![[Excalidraw/github/pull-request.excalidraw.png]]\n\n## Sync Fork Repository\nUsually, any open source project has a very high commit frequency, as there are so many contributors who keep on adding stuff on the go. This also means, your fork is going to go out-of-sync/outdated very frequently. Thus, we need to keep `main` from our fork repository in sync with `main` from the source project. This can be done using the concept of upstream. Your local git repository has a table of remote URLs, this can be viewed using `git remote -v`. You can configure your local repository to have an `upstream` remote URL referring to the source project repo. You always pull changes from `upstream: main` and push them to `origin: main`.\n![[Excalidraw/github/sync-fork.excalidraw.png]]\n\n## Important Tips\n- Avoid changes to `main` branches, if you commit something in main and it diverges from `upstream: main`, it will become very difficult to reconcile changes\n- Always create a new branch from `main` when working on a new feature\n- A fork can be created under any `user` or `org`, you can have a fork under org to share across the team\n- As long as your `.git` folder is intact, you can recover any changes you lose from the working directory\n- Pull requests are not essential, but help the maintainer when reviewing changes\n\n## Conclusion\nThis note only covers the bare minimum required to start contributing to git projects. Additional reading is recommended to understand git fundamentals.","lastmodified":"2022-05-23T10:02:02.311103664Z","tags":null},"/devops/moc":{"title":"DevOps MOC","content":"[[devops/gh_contribution|Github: Contribution Workflow]]","lastmodified":"2022-05-23T10:02:02.311103664Z","tags":null},"/notes/oauth2":{"title":"The OAuth 2.0 Authorization Framework : Conceptual Overview","content":"The OAuth 2.0 Authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf.\n\n**Real world example** - Login/Signup with google button in third party websites like twitter, linkedin, etc use oauth 2.0 for authorization from your existing google account.\n\n## Introduction\nFollowing figure shows traditional client-server authentication model.\n\n![[Excalidraw/oauth/traditional-client-server-auth.excalidraw.png]]\n\nProblems \u0026 Limitations with this approach:\n- Third-party applications store resource owner's credentials\n- Resource servers are required to support password authentication\n- Third-party applications gain overly broad access to resources because credentials are shared\n- Resource owner's lack ability to restrict duration or access to subset of resources\n- Resource owner's cannot revoke access to individual third party without changing credentials\n- Compromise of third-party application results in compromise of the end-user's password and all data protected by that password\n\nOAuth addresses these issues by introducing an authorization layer and separating the role of the client and resource owner. In OAuth, every client is issued different set of credentials than those of the resource owner. Instead of using the resource owner's credentials to access protected resources, the client obtains an access token -- a string denoting a specific scope, lifetime, and other access attributes. Access tokens are issued to third-party clients by an authorization server with the approval of the resource owner. The client uses the access token to access the protected resources hosted by the resource server.\n\n### Roles\nOAuth defines four roles:\n1. **Resource owner** - An entity capable of granting access to a protected resource. When the resource owner is a person, it is referred to as an end-user. Example - Google account owner/end user\n2. **Resource server** - The server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens. Example - [People API](https://developers.google.com/people/)\n3. **Client** - An application making protected resource requests on behalf of the resource owner and with its authorization. The term \"client\" does not imply any particular implementation characteristics (e.g., wheather the application executes on a server, a desktop, or other devices). Example - Twitter web/android app\n4. **Authorization Server** - The server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization. Example - [Google Identity Service](https://developers.google.com/identity)\n\nReal world example showing all roles - When you press login with google button in twitter(**Client**) login page, it redirects you to google(**Authorization Server**) login page. After logging into google, it requests your(**Resource Owner**) permission to allow access to your contacts from People API(**Resource Server**). Twitter uses this contact info to suggest people to follow.\n\n### Protocol Flow\n![[Excalidraw/oauth/abstract-protocol-flow.excalidraw.png]]\n\nThe figure above illustrates abstract OAuth 2.0 flow with interaction between the 4 roles and includes following steps:\n\n\u003col type=\"A\"\u003e\n\t\u003cli\u003eClient request authorization from request owner\u003c/li\u003e\n\t\u003cli\u003eClient receives authorization grant, which is a credential representing the resource owner's authorization.\u003c/li\u003e\n\t\u003cli\u003eClient requests an access token by authenticating with authorization server and presenting authorization grant\u003c/li\u003e\n\t\u003cli\u003eAuthorization server authenticates client and validates authorization grant, and if valid, issues an access token.\u003c/li\u003e\n\t\u003cli\u003eClient requests protected resource from resource server presenting access token\u003c/li\u003e\n\t\u003cli\u003eResource server validates access token, and if valid, server the request\u003c/li\u003e\n\u003c/ol\u003e\n\n### Authorization Grant\nAuthorization grant is a credential representing resource owner's authorization used by the client to obtain an access token.\n\nThere are 4 types of authorization grant:\n1. Authorization Code Grant\n2. Implicit Grant\n3. Resource Owner Password Credentials Grant\n4. Client Credentials Grant\n\n[RFC 6749: The OAuth 2.0 Authorization Framework)](https://www.rfc-editor.org/rfc/rfc6749.html) also provides extensibility mechanism for defining additional types.\n\n### Access Token\nAccess tokens are credentials used to access protected resources. An access token is a string representing an authorization issues to the client. The string is usually opaque to the client. Tokens represent specific scopes and durations of access, granted by resource owner, and enforced by resource server and authorization server.\n\n### Refresh Token\nRefresh tokens are credentials used to obtain access tokens. Refresh tokens are issued to the client by the auhorization server and are used to obtain a new access token when current access token becomes invalid ot expires, or to obtain additional access token with narrower scope (access tokens may have shorter lifetime and fewer permissions than authorized by resource owner).\n\n\u003cspan style=\"color: red;\"\u003e\nRefresh tokens are intended for use only with authorization server and are never sent to resource servers.\n\u003c/span\u003e\n\nFollowing figure illustrates how refresh tokens are used to get new access token.\n\n![[Excalidraw/oauth/refresh-expired-access-token.excalidraw.png]]\n\n## Client Registration\nBefore initiating the protocol, client registers itself with authorization server. This process is beyond the scope of this note but typically involves end-user interaction with an HTML registration form. \n\nExample - Google Login Page after getting redirected by a website\n\nWhen registering a client, the client developer shall:\n- specify the client type\n- provide its client redirection URIs\n- include any other information required by the authorization server (e.g., application name, website, description, logo image, the acceptance of legal terms)\n\n### Client Types\nOAuth defines 2 client types, based on their ability to authenticate securely with the authorization server (i.e., ability to maintain the confidentiality of their client credentials):\n\n- **confidential** : Clients capable of maintaining the confidentiality of their credentials (e.g., client implemented on a secure server with restricted access to client credentials), or capable of secure client authentication using other means. \n- **public** : Client incapable of maintaining the confidentiality if their credentials (e.g., clients executing on the device used by the resource owner, such as an installed native application or a web browser-based application), and incapable of secure client authentication via any other means.\n\n\u003cspan style=\"color: red;\"\u003e\nAuthorization server SHOULD NOT make assumptions about the client type.\n\u003c/span\u003e\n\nClient type specification mentioned above was designed around the following client profiles:\n- **Web application** : A web application is a confidential client running on a web server. Resource owners access the client via an HTML user interface rendered in a user-agent on the device used by the resource owner. The client credentials as well as any access token issued to client are stored on the web server and are not exposed to or accessible by resource owner.\n- **User-agent-based application** : A user-agent-based application is a public client in which the client code is downloaded from a web server and executes within a user-agent(e.g., web browser) on the device used by the resource owner. Protocol data and credentials are easily accessible (and often visible) to resource owner. Since such applications reside within the user-agent, they can make seamless use of the user-agent capabilities when requesting authorization.\n- **Native application** : A native application is a public client installed and executed on the device used by the resource owner. Protocol data and credentials are accessible to the resource owner. It is assumed that any client authentication credentials included in the application can be extracted. On the other hand, dynamically issued credentials such as access tokens or refresh tokens can receive acceptable level of protection. At a minimum, these credentials are protected from hostile servers with which the application may interact. On some platforms, these credentials might be protected from other applications residing on the same device.\n\n### Client Identifier\nAuthorization server issues a unique client identifier to every registered client. Client identifier is not a secret and is exposed to resource owner.\n\n### Client Authentication\nFor confidential client type, client and authorization server establish client authentication method suitable for the security requirement of the authorization server.\n\nConfidential clients are typically issues a set of client credentials used for authenticating with the authorization server (e.g., password, public/private key pair). **Example** - Applications in Cloud Foundry may use client credentials present in **VCAP_SERVICES** for any oauth secured service.\n\n## Protocol Endpoints\nThe authorization process utilizes 2 authorization server endpoints (HTTP resources):\n- **Authorization Endpoint** - used by the client to obtain authorization from the resource owner via user-agent redirection.\n- **Token Endpoint** - used by the client to exchange an authorization grant for an access token, typically with client authentication.\n\n\u003cspan style=\"color: red;\"\u003e\nNot every authorization grant type utilizes both endpoints.\n\u003c/span\u003e\n\nAs well as one client endpoint:\n- **Redirection endpoint** - used by the authorization server to return responses containing authorization credentials to the client via the resource owner user-agent.\n\n## Obtaining Authorization\nTo request an access token, the client obtains authorization from the resource owner. The authorization is expressed in the form of an authorization grant, which client uses to request access token.\n\n### Authorization Code Grant\n\nThe authorization code grant type is used to obtain both access tokens and refresh tokens and is optimized for confidential clients.\nSince this is a redirection-based flow, the client must be capable of interacting with the resource owner's user-agent (typically a web browser) and capable of receiving incoming requests (via redirection) from the authorization server. \n\nThe Authorization Code grant can be used anytime you connect a user¬†profile to one or multiple accounts from within a website¬†and for instance you authorize¬†the website to access information owned from LinkedIn, Facebook, Twitter, etc‚Ä¶.even all at the same time.\n\nExample - Connecting linkedin account to twitter account and allowing linkedin to access your twitter timeline information.\n\n![[Excalidraw/oauth/authorization-code-flow.excalidraw.png]]\n\u003cspan style=\"color: red;\"\u003e\nThe lines illustrating steps A, B, C are broken into two parts as they pass through the user-agent.\n\u003c/span\u003e\n\n\n### Implicit Grant\n\nThe implicit grant type is used to obtain access tokens(without any support for refresh token) and is optimized for public clients known to operate a particular redirection URI. These clients are typically implemented in a browser using a scripting language such as Javascript.\n\nSince this is a redirection-based flow, the client must be capable of interacting with the resource owner's user-agent (typically a web browser) and capable of receiving incoming requests (via redirection) from the authorization server.\n\nUnlike the authorization code grant type, in which the client makes separate requests for authorization and for an access token, the client receives the access token as the result of the authorization request.\n\nThe implicit grant type does not include client authentication, and relies on the presence of the resource owner and the registration of the redirection URI.  \n\nThe Implicit Grant is very similar to the Authorization grant , but is not as secure as the first one. Another application running on the same machine / device could steal the authorization information exchanged between the client and the third party library and use it.\n\nA malicious client can impersonate another client and obtain access to protected resources, if the impersonated client fails to, or is unable to, keep its client credentials confidential. For more details read [draft-ietf-oauth-v2-31](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-31#section-10.2).\n\n\nExample - Applications leaving context and opening new window to authenticate. Real examples include android web apps \u0026 some websites redirecting you to another website in new tab. The control moves from your application to another website in  new tab, thus making it very risky.\n\n\u003cspan style=\"color: red;\"\u003e\nThe access token is encoded into the redirection URI, it may be exposed to the resource owner and other applications residing on the same device.\n\u003c/span\u003e\n\n![[Excalidraw/oauth/implicit-grant-flow.excalidraw.png]]\n\u003cspan style=\"color: red;\"\u003e\nThe lines illustrating steps A and B are broken into two parts as they pass through the user-agent.\n\u003c/span\u003e\n\n### Resource Owner Password Credentials Grant\n\nThe resource owner password credentials grant type is suitable in cases where the resource owner has a trust relationship with the client, such as the device operating system or a highly privileged application.\n\nThis grant type is suitable for clients capable of obtaining the resource owner's credentials (username and password, typically using an interactive form).  It is also used to migrate existing clients using direct authentication schemes such as HTTP Basic or Digest authentication to OAuth by converting the stored credentials to an access token.\n\nExample - Standalone applications in your device like netflix app in andorid phone.\n\n\u003cspan style=\"color: red;\"\u003e\n The authorization server should take special care when enabling this grant type and only allow it when other flows are not viable.\n\u003c/span\u003e\n\n![[Excalidraw/oauth/resource-owner-password-credentials-flow.excalidraw.png]]\n\n### Client Credentials Grant\n\n The client can request an access token using only its client credentials (or other supported means of authentication) when the client is requesting access to the protected resources under its control, or those of another resource owner that have been previously arranged with the authorization server).\n\nExample - Application Hosted in Cloud Foundry authenticating to get access to backing service.\n\n\u003cspan style=\"color: red;\"\u003e\nThis flow doesn't involve any end-user and should only be used for machine-to-machine authentication in order to allow some server side code to access some protected resource like third-party Web API.\n\u003c/span\u003e\n\n![[Excalidraw/oauth/client-credentials-flow.excalidraw.png]]\n\n## Conclusion\nI didn't cover authorization request/response, access token request/response formats and security considerations here. Please refer RFC for getting detailed request/response formats. The OAuth 2.0 Core Framework (RFC 6749) only defines roles and a base level of functionality. Implementation details are left unspecified as out of scope for RFC. OAuth Working Group has published additional RFCs built on top of core framework to fill missing gaps. I would try covering some of those RFCs in future notes. \n\nThis note only covers essential content from [RFC 6749: The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749.html).","lastmodified":"2022-05-23T10:02:02.311103664Z","tags":null},"/random/java_11_collections":{"title":"Java 11 Fundamentals: Collections","content":"---\n\nEvery application requires wide variety of data structures based on your use case. Implementing every basic data structures yourself is error prone, it's hard to get everything right. This is one of the reasons why java provides [collection](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/Collection.html) with jdk. \n\n## The Array Problem\nSome may argue why not use array everywhere? \nYes, you can but is it worth it? \n\nGiven below are some problems associated with array: \n- Increasing size - Adding new elements in already filled array requires creating new array and copying values from old one. Old array is left for garbage collection, resulting in memory wastage.\n- Homogeneous object storage - You can only store objects of same type in an array.\n- Deletion \u0026 Insertion - You cannot easily insert or delete elements at middle of the array.\n\nApart from the issues above, the complexity is also very bad for frequently used operations in array.\n\n|        Array Operation         | Real Time Complexity | Assumed Time Complexity |\n|:","lastmodified":"2022-05-23T10:02:02.311103664Z","tags":null},"/system_design/moc":{"title":"System Design MOC","content":"- [[system_design/scale_zero_millions|Scale from 0 to Millions of Users]]","lastmodified":"2022-05-23T10:02:02.311103664Z","tags":null}}